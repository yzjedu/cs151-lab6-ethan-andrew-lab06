ENCRYPTED:
# Mzagzxodji Yjxphzio

* Ymdqz Apgg Ivhz  : 
* Kvmoizm Apgg Ivhz: 
* Nopyzio DY: 

Name: Ethan D’Souza
Student ID: 1735988

Objective:
In this lab, we were tasked with refactoring the ATM program from Lab 5, with the main goals being to organize the code into functions and incorporate proper error checking. We were supposed to learn how to break a larger program into smaller, reusable parts, otherwise known as refactoring code.
Procedure:
The steps followed included reviewing the existing ATM code, identifying areas where functions could be applied, and creating a structure for the refactored program. Andrew and I planned out functions for handling menu options, deposits, withdrawals, and viewing the balance. We also mapped out a flowchart, in order to help us plan out our program. We focused on ensuring the program could repeatedly prompt the user until valid input was provided.
Key concepts explored included:
* Function creation and organization
* Input validation with loops
* Error handling
* Modularizing code for reusability and clarity
Results:
The results matched what we expected. Our refactored ATM program ran correctly, and the input validation worked as intended. We tested various scenarios, including valid deposits and withdrawals, negative inputs, and invalid menu choices. Additionally, we ran extreme cases, such as trying to withdraw more than the current balance, to ensure the negative balance and fee functionality worked as specified.
Reflection:
One of the challenges we encountered was understanding how to structure the code into functions without repeating too much of the logic from Lab 5. Breaking the program into parts while maintaining readability and flow took some practice.
Regarding the three rules of programming:
1. Identify the Problem: We clearly identified the hard tasks of the program and broke them into functions. 
2. Design and Plan: We planned by deciding which functions would handle specific tasks, and how to structure the program for clarity.
3. Execute and Test: We implemented each function and tested it thoroughly. Frequent testing helped us catch issues early.
We overcame challenges by starting with small steps, first refactoring the code without adding error checking, then progressively adding features and testing frequently. By breaking the task into smaller parts, it was easier to manage.
Some key takeaways include the importance of refactoring code, using functions. I also got a lot of experience working with functions and it helped me understand them more.
Working with Andrew was a great experience. We split the tasks well—I worked on the test cases, Andrew focused on algorithm design and flowchart, and I worked more on the coding. We communicated well and were able to solve issues quickly together.














